//_________________________________________________________________________________________________
//|                                                                                      -- INFO --
//| Name        : Netlist_Listener.ihh
//| Author(s)   : Niklas Een
//| Module      : Netlist
//| Description : Listener model for netlist updates.
//| 
//| (C) Copyright 2010-2012, The Regents of the University of California
//|________________________________________________________________________________________________
//|                                                                                  -- COMMENTS --
//| NOTE! Listeners must not add or remove netlists when responding to a message.
//|________________________________________________________________________________________________


#ifndef NL_LIS_IMPLEMENTATION
//mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
// Messages:


enum NlMsg {
    // Messages generated by netlist implementation:
    //
    msg_Update,     // -- a fanin has changed 
    msg_Add,        // -- a gates has been added (called before children are connected and attribute is set (attribute changes cannot be listened to))
    msg_Remove,     // -- a gate is about to be removed (children are NOT explicitly disconnected; this message is the only signal of the fanout change)
    msg_Compact,    // -- netlist was compacted (IDs have changed)

    // User messages:
    //
    msg_EqMove,     // -- fanouts of a gate was transferred to an equivalent gate

    NlMsg_size,     // -- must be <= 64
    msg_NULL = NlMsg_size
};


typedef uint64 NlMsgs;

macro NlMsgs NlMsgs_new(NlMsg m0) { return uint64(1) << m0; }
macro NlMsgs NlMsgs_new(NlMsg m0, NlMsg m1) { return (uint64(1) << m0) | (uint64(1) << m1); }
macro NlMsgs NlMsgs_new(NlMsg m0, NlMsg m1, NlMsg m2) { return (uint64(1) << m0) | (uint64(1) << m1) | (uint64(1) << m2); }
macro NlMsgs NlMsgs_new(NlMsg m0, NlMsg m1, NlMsg m2, NlMsg m3) { return (uint64(1) << m0) | (uint64(1) << m1) | (uint64(1) << m2) | (uint64(1) << m3); }
macro NlMsgs NlMsgs_new(NlMsg m0, NlMsg m1, NlMsg m2, NlMsg m3, NlMsg m4) { return (uint64(1) << m0) | (uint64(1) << m1) | (uint64(1) << m2) | (uint64(1) << m3) | (uint64(1) << m4); }

static const NlMsgs msgs_AllCore ___unused = NlMsgs_new(msg_Update, msg_Add, msg_Remove, msg_Compact);
static const NlMsgs msgs_All     ___unused = (1ull << NlMsg_size) - 1;


#else
#undef NL_LIS_IMPLEMENTATION
//mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
// Listener abstract base-class:


struct NlLis {
    netlist_id nl;

    virtual void update(Wire w, uint pin, Wire w_old, Wire w_new) {}
    virtual void add   (Wire w) {}
    virtual void remove(Wire w) {}
    virtual void compact(const Vec<gate_id>& new_ids) {}

    // User messages:
    virtual void eqMove(Wire w_src, Wire w_dst) {}

    // -- add more messages here (and also below in 'SendProxy').

    NlLis(netlist_id nl_) : nl(nl_) {}
    virtual ~NlLis() {}
};


//mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
// Send proxy for user messages:


struct SendProxy : NlLis {
    SendProxy(netlist_id nl, const Vec<NlLis*>* listeners_) : NlLis(nl) {}

    void update(Wire, uint, Wire, Wire) { assert(false); }
    void add   (Wire) { assert(false); }
    void remove(Wire) { assert(false); }
    void compact(const Vec<gate_id>&) { assert(false); }

    // User messages:
    void eqMove(Wire w_src, Wire w_dst) {
        const Vec<NlLis*>& ls = global_netlists_[nl].listeners[msg_EqMove];
        for (uind i = 0; i < ls.size(); i++) ls[i]->eqMove(w_src, w_dst); }

    // -- add more messages here.
};


//mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
#endif
