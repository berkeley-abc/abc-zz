diff --git a/minisat/core/SolverTypes.h b/minisat/core/SolverTypes.h
index f12881b..8819a62 100644
--- a/minisat/core/SolverTypes.h
+++ b/minisat/core/SolverTypes.h
@@ -41,7 +41,11 @@ namespace Minisat {
 // so that they can be used as array indices.
 
 typedef int Var;
+#if defined(MINISAT_CONSTANTS_AS_MACROS)
 #define var_Undef (-1)
+#else
+  const Var var_Undef = -1;
+#endif
 
 
 struct Lit {
@@ -86,10 +90,6 @@ template<class T> class LMap : public IntMap<Lit, T, MkIndexLit>{};
 //       does enough constant propagation to produce sensible code, and this appears to be somewhat
 //       fragile unfortunately.
 
-#define l_True  (lbool((uint8_t)0)) // gcc does not do constant propagation if these are real constants.
-#define l_False (lbool((uint8_t)1))
-#define l_Undef (lbool((uint8_t)2))
-
 class lbool {
     uint8_t value;
 
@@ -119,6 +119,17 @@ public:
 inline int   toInt  (lbool l) { return l.value; }
 inline lbool toLbool(int   v) { return lbool((uint8_t)v);  }
 
+#if defined(MINISAT_CONSTANTS_AS_MACROS)
+  #define l_True  (lbool((uint8_t)0)) // gcc does not do constant propagation if these are real constants.
+  #define l_False (lbool((uint8_t)1))
+  #define l_Undef (lbool((uint8_t)2))
+#else
+  const lbool l_True ((uint8_t)0);
+  const lbool l_False((uint8_t)1);
+  const lbool l_Undef((uint8_t)2);
+#endif
+
+
 //=================================================================================================
 // Clause -- a simple class for representing a clause:
 
@@ -147,12 +158,13 @@ class Clause {
         for (int i = 0; i < ps.size(); i++) 
             data[i].lit = ps[i];
 
-        if (header.has_extra)
+        if (header.has_extra){
             if (header.learnt)
                 data[header.size].act = 0;
             else
                 calcAbstraction();
     }
+    }
 
     // NOTE: This constructor cannot be used directly (doesn't allocate enough memory).
     Clause(const Clause& from, bool use_extra){
@@ -162,12 +174,13 @@ class Clause {
         for (int i = 0; i < from.size(); i++)
             data[i].lit = from[i];
 
-        if (header.has_extra)
+        if (header.has_extra){
             if (header.learnt)
                 data[header.size].act = from.data[header.size].act;
             else 
                 data[header.size].abs = from.data[header.size].abs;
     }
+    }
 
 public:
     void calcAbstraction() {
diff --git a/minisat/mtl/IntMap.h b/minisat/mtl/IntMap.h
index 2f44bd6..a37be78 100644
--- a/minisat/mtl/IntMap.h
+++ b/minisat/mtl/IntMap.h
@@ -49,7 +49,7 @@ namespace Minisat {
         void     insert (K key, V val, V pad){ reserve(key, pad); operator[](key) = val; }
         void     insert (K key, V val)       { reserve(key); operator[](key) = val; }
 
-        void     clear  (bool dispose = false) { map.clear(false); }
+        void     clear  (bool dispose = false) { map.clear(dispose); }
         void     moveTo (IntMap& to)           { map.moveTo(to.map); to.index = index; }
         void     copyTo (IntMap& to) const     { map.copyTo(to.map); to.index = index; }
     };
diff --git a/minisat/mtl/Vec.h b/minisat/mtl/Vec.h
index dc08a16..5c188ff 100644
--- a/minisat/mtl/Vec.h
+++ b/minisat/mtl/Vec.h
@@ -99,8 +99,8 @@ void vec<T,_Size>::capacity(Size min_cap) {
     if (cap >= min_cap) return;
     Size add = max((min_cap - cap + 1) & ~1, ((cap >> 1) + 2) & ~1);   // NOTE: grow by approximately 3/2
     const Size size_max = std::numeric_limits<Size>::max();
-    if ((size_max <= std::numeric_limits<int>::max()) && (add > size_max - cap) 
-    || ((data = (T*)::realloc(data, (cap += add) * sizeof(T))) == NULL) && errno == ENOMEM)
+    if ( ((size_max <= std::numeric_limits<int>::max()) && (add > size_max - cap))
+    ||   (((data = (T*)::realloc(data, (cap += add) * sizeof(T))) == NULL) && errno == ENOMEM) )
         throw OutOfMemoryException();
  }
 
diff --git a/minisat/utils/Options.h b/minisat/utils/Options.h
index 2dba10f..df80429 100644
--- a/minisat/utils/Options.h
+++ b/minisat/utils/Options.h
@@ -60,7 +60,7 @@ class Option
     struct OptionLt {
         bool operator()(const Option* x, const Option* y) {
             int test1 = strcmp(x->category, y->category);
-            return test1 < 0 || test1 == 0 && strcmp(x->type_name, y->type_name) < 0;
+            return test1 < 0 || (test1 == 0 && strcmp(x->type_name, y->type_name) < 0);
         }
     };
 
