//_________________________________________________________________________________________________
//|                                                                                      -- INFO --
//| Name        : VerilogWriter.cc
//| Author(s)   : Niklas Een
//| Module      : Verilog
//| Description : Write back a parsed and flattened Verilog file.
//| 
//| (C) Copyright 2010-2014, The Regents of the University of California
//|________________________________________________________________________________________________
//|                                                                                  -- COMMENTS --
//| 
//|________________________________________________________________________________________________

#include "Prelude.hh"
#include "VerilogWriter.hh"
#include "Parser.hh"

namespace ZZ {
using namespace std;


//mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm


// Outputs a single, combinational netlist (with standard cells) in structual Verilog format.
void writeFlatVerilog(Out& out, String module_name, NetlistRef N, const SC_Lib& L)
{
    Vec<char>  buf, buf1, buf2;
    String     scratch;
    Vec<char>  text;
    WMap<uind> names(0);   // -- maps gates to offsets in 'text' (offset 0 = no name).
    text.push(0);

    bool has_lookup = N.names().hasLookup();
    N.names().enableLookup();

    Auto_Pob(N, fanouts);

    // Creation comment:
    FWriteLn(out) "// Generated by ABC/ZZ on %_", dateAndTimeText();
    FNewLine(out);

    // Module header:
    FWrite(out) "module \\%_ (\n/*inputs:*/   ", module_name;
    bool first = true;
    For_Gatetype(N, gate_PI, w){
        if (first) first = false;
        else       out += ',';
        char* name = N.names().get(w, buf);
        FWrite(out) " \\%_ ", name;

        // Store input name:
        names(w) = text.size();
        append(text, slize(name));
        text.push(0);
    }
    FWrite(out)"\n/*outputs:*/ ";
    size_t pfx_len = strlen(verilog_module_output_prefix);
    For_Gatetype(N, gate_PO, w){
        char* name = N.names().get(w, buf);
        assert(pfx(name, verilog_module_output_prefix));
        FWrite(out) ", \\%_ ", name + pfx_len;

        GLit p = N.names().lookup(name + pfx_len);
        assert(p != glit_NULL);
    }
    FWriteLn(out)"\n);";

    // Wire declarations:
    first = true;
    FWrite(out) "  input ";
    For_Gatetype(N, gate_PI, w){
        if (first) first = false;
        else       out += ',';
        FWrite(out) " \\%_ ", N.names().get(w, buf);
    }
    FWriteLn(out) ";";

    first = true;
    FWrite(out) "  output";
    For_Gatetype(N, gate_PO, w){
        if (first) first = false;
        else       out += ',';

        char* name = N.names().get(w, buf);
        assert(pfx(name, verilog_module_output_prefix));
        FWrite(out) " \\%_ ", name + pfx_len;
    }
    FWriteLn(out) ";";

    FWrite(out) "  wire  ";
    first = true;
    For_Gates(N, w){
        if (type(w) == gate_PI || type(w) == gate_PO)
            ;/*nothing*/
        else{
            assert(type(w) == gate_Uif || type(w) == gate_Pin);
            bool found = false;
            for (uint i = N.names().size(w); i > 0;){ i--;
                char* n = N.names().get(w, buf, i);
                if (!pfx(n, verilog_instance_prefix)){
                    if (first) first = false;
                    else       out += ',';

                    FWrite(out) " \\%_ ", n;
                    found = true;
                    break;
                }
            }

            if (!found){
                assert(type(w) == gate_Uif);
                assert(L.cells[attr_Uif(w).sym].n_outputs > 1); }
        }
    }
    FWriteLn(out) ";";

    // Module body:
    Vec<GLit> order;
    topoOrder(N, order);

    for (uint n = 0; n < order.size(); n++){
        Wire w = order[n] + N;

        if (type(w) == gate_PI || type(w) == gate_PO || type(w) == gate_Pin)
            continue;

        assert(type(w) == gate_Uif);
        const SC_Cell& cell = L.cells[attr_Uif(w).sym];
        bool multi_output = cell.n_outputs > 1;

        // Find signal and instance name:
        char* sig_name  = NULL;
        char* inst_name = NULL;
        size_t pfx_len = strlen(verilog_instance_prefix);
        for (uint i = 0; i < N.names().size(w); i++){
            char* n = N.names().get(w, buf, i);
            if (pfx(n, verilog_instance_prefix)){
                buf.copyTo(buf1);
                inst_name = &buf1[pfx_len];
            }else{
                buf.copyTo(buf2);
                sig_name = &buf2[0];
            }
        }

        if (!multi_output){
            assert(sig_name  != NULL);
            assert(inst_name != NULL);

            // Store signal name:
            names(w) = text.size();
            append(text, slize(sig_name));
            text.push(0);

            scratch.clear();
            FWrite(scratch) ".%_(\\%_ )", cell.pins[w.size()].name, sig_name;

        }else{
            assert(sig_name  == NULL);
            assert(inst_name != NULL);

            // Loop over output pins and store signal names:
            scratch.clear();
            bool first = true;
            Fanouts fs = fanouts[w];
            for (uint j = 0; j < fs.size(); j++){
                Wire v = fs[j]; assert(type(v) == gate_Pin);

                for (uint i = N.names().size(v); i > 0;){ i--;
                    char* n = N.names().get(v, buf, i);
                    if (!pfx(n, verilog_instance_prefix)){
                        // Store signal name:
                        names(v) = text.size();
                        append(text, slize(n));
                        text.push(0);

                        if (first) first = false;
                        else scratch += ", ";
                        FWrite(scratch) ".%_(\\%_ )", cell.pins[w.size() + attr_Pin(v).number].name, n;
                        break;
                    }
                }
            }
        }

        // Write gate instantiation:
        FWrite(out) "  %_ \\%_ (", cell.name, inst_name;

        For_Inputs(w, v){
            assert(!sign(v));
            uind off = names[v]; assert(off != 0);

            FWrite(out) ".%_(\\%_ ), ", cell.pins[Iter_Var(v)].name, &text[off];
        }

        FWriteLn(out) "%_);", scratch;
    }

    // Aliases:
    For_Gates(N, w){
        for (uint i = 0; i < N.names().size(w); i++){
            char* n = N.names().get(w, buf, i);
            if (pfx(n, verilog_instance_prefix))      continue;
            if (pfx(n, verilog_module_output_prefix)) continue;

            char* m = &text[names[w]];
            if (strcmp(n, m) != 0)
                FWriteLn(out)  "  assign \\%_ = \\%_ ;", n, m;
        }
    }

    // Finalize:
    FWriteLn(out) "endmodule";
    if (!has_lookup)
        N.names().disableLookup();
}


bool writeFlatVerilogFile(String filename, String module_name, NetlistRef N, const SC_Lib& L)
{
    OutFile out(filename);
    if (out.null()) return false;

    writeFlatVerilog(out, module_name, N, L);
    return true;

}


//mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
}
